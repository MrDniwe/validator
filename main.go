package main

import (
	"errors"

	"github.com/google/logger"
)

// Pipeline - интерфейс экземпляра пайплайна, то есть набора цепочек валидаций
// В нем должны находиться все инициированные экземпляры джоб.
// - Каждая из джоб должна быть в состоянии найти нужную ей джобу - источник данных
type Pipeline interface {
	// StartPipe - вызов этого метода дергает метод Go в каждой джобе этого пайплайна
	StartPipe() error
	// GetJobByName - метод по которому джоббы пайплайна могут обратиться к нему
	// и получить интересующую их джобу по её предполагаемомоу имени
	GetJobByName(name string) (Job, error)
}

// Job - Каждый узел графа - это джоба
type Job interface {
	// Go - после вызова этого метода, джоба начинает выполняться
	// подразумевается что пайплайн дёрнет этот метод у всех джоб на старте
	// Пайплайн вызывая метод передает джобам ссылку на себя, чтобы они могли найти другие джобы
	Go(Pipeline) error
	// GetDataChan - одна джоба может попросить у другой дать ей канал с её данными
	// - Подразумевается что джоба-владелец данных начнёт итерировать отправку
	// своих данных в этот канал или вообще просто отдаст в канал указатель на все данные сразу
	// - У джобы может быть сколько угодно потребителей, она запоминает каждого при вызове
	// этого метода и работает с каждым отдельно
	GetDataChan() DataChan
}

// DataChan - универсальный тип канала с данными
// Мы не знаем что за данные будет отправлять отдельная джоба,
// скорее всего нужно будет приводить типы по интерфейсу
// Возможно лучше сделать не канал с пустым интерфейсом, а просто пустой интерфейс,
// который джоба будет ассертить на старте в канал нужного ей типа (так можно вообще?)
type DataChan chan interface{}

// --- Опишем простейшую джобу
type dumbJob struct {
	// Это экземпляр другой джобы, нужной этой джобе
	// Он после конструктора пустой, но после вызова метода Go будет заполнен
	// джобой, найденной в пайплайне
	source Job
	// это данные которыми владеет джоба
	// теоретически, тут может быть например клиент редиса
	data []string
}

func (d dumbJob) Go(pipe Pipeline) error {
	var err error
	// ищем джобу с исходными данными
	d.source, err = pipe.GetJobByName("source")
	// у пайпа нет такой джобы, валим
	if err != nil {
		return err
	}
	// начинаем потреблять данные из источника
	srcChan := d.source.GetDataChan()
	// В горутине запускаем
	// тут можно в перспективе целый воркер пул запустить и читать из канала всем вместе
	go func() {
		for r := range srcChan {
			if row, ok := r.(string); ok {
				// занимаемся например глупой работой - удваиваем строку через пробел
				// и сохраняем в хранилище джобы
				d.data = append(d.data, row+" "+row)
			}
		}
	}()
	// канал получен, воркеры запущены, сообщаем пайплайну что у нас всё ок
	return nil
}

// Для каждого нового слушателя делаем канал и открываем горутину которая шлет данные
func (d dumbJob) GetDataChan() DataChan {
	c := make(DataChan)
	go func(c DataChan) {
		// Просто отдаем все данные которыми владеем, построчно
		// Это совсем грубый пример, надо либо начинать отдавать когда все данные готовы (нужен семафор)
		// либо придумать хитрую схему как отдавать пополняемые данные (нужен инфоканал из воркеров метода Go)
		for d := range d.data {
			c <- d
		}
	}(c)
	return c
}

// NewDumbJob конструктор джобы
func NewDumbJob() Job {
	return dumbJob{
		source: nil,
		data:   make([]string, 0, 100),
	}
}

// --- Опишем пайплайн
type pipeline struct {
	// все имеющиеся джобы пайпа поименно
	jobs map[string]Job
}

func (p pipeline) GetJobByName(name string) (Job, error) {
	if job, ok := p.jobs[name]; ok {
		return job, nil
	}
	return nil, errors.New("job not found")
}

func (p pipeline) StartPipe() error {
	// проходим по всем джобам пайплайна и стартуем их
	for _, job := range p.jobs {
		err := job.Go(p)
		// если хоть одна не взлетела - пайп не рабочий
		if err != nil {
			return err
		}
	}
	return nil
}

func NewPipeline(
	sourceJob Job,
	dumbJob Job,
) Pipeline {
	jobs := make(map[string]Job)
	jobs["source"] = sourceJob
	jobs["dumb"] = dumbJob
	return pipeline{
		jobs: jobs,
	}
}

// --- Как это должно стартовать
func main() {
	// Тут джобы с источником данных (все наши строки экселя)
	// Это источник
	sourceJob := NewDumbJob() // но я не написал его, так что тут другой чтоб не сыпать ошибками
	// Это какой-то обработчик (или валидатор)
	dumbJob := NewDumbJob()
	// TODO: тут должна быть какая-то джоба или нечто иное для получения окончательного результата

	// Инитим пайп с этими джобами
	pipe := NewPipeline(sourceJob, dumbJob)

	// Запускаем пайп, на каждую отдельную обработку просто запускаем новый пайплайн
	err := pipe.StartPipe()
	// Не стартанул(
	if err != nil {
		logger.Fatal(err)
	}

}
